############################################################################################ SUITCEYES Serial Controller Illustration v1.0# by Dr Raymond Holt, University of Leeds## This code was developed as part of the SUITCEYES project (http://suitceyes.eu), and is owned by the SUITCEYES consortium. # It may not be modified or redsitributed without the consortium's express permission.## created 3rd May 2019# by Raymond Holt## Version History# v1.0 Raymond Holt (UNIVLEEDS) 3rd May 2019 - first version uploaded to Box for illustration of controller. ## OVERVIEW# This program is intended to illustrate use of the SUITCEYES python module to communicate with the Arduino Controller developed in Work Package 5.# It requires that the SUITCEYES.py module is in the working directory and imported.# This provides three modes for interacting with the controller:#  1) By specifying the intensity of every channel during each frame - this allows control of multiple channels simultaneously, but is both slower to transmit and to write;#  2) By specifying the intensity and duration of each frame for a single channel - this is faster to transmit, but only permits one motor to be operated during the signal; and#  3) By specifying a channel, intensity and duration for each frame - this allows only one channel frame, but is faster than method 1, and allows multiple channels to be used in a single signal. ##Program Begins##import required libraries import SUITCEYESimport sysimport serialimport csvimport time########################################################################################################################################### User defined variables - use these variables to customise the behaviour of the code.##########################################################################################################################################Timing_Data_Wanted = True; #Determine whether timing files should be written. True will produce a .csv of timing data for every file. Feedback_Data_Wanted = True; #Determine whether feedback files should be written. True will produce a .csv of feedbackk data for every file.Signal_Select = True; #Determine whether to allow users to select which signal to display, or to automatically run through each row of the Haptic Library in turn. True means users will be prompted for the row to use before each trial.arduinoport = "COM7" #Set the COM port for the arduinodir_path = "/Users/rayjh/Documents/Work/SuitCEYES/" #Set the Path where the Haptic Library will be read from, and output files will be written to.haptic_library_title = "Thessaloniki Demos.csv" #title of haptic library file to use.prompt = "Which direction?" #This customises the prompt for recording answers at the end of the trial.channels = 2 #defines number of channels.sensors = 2 #defines number of channels.Verbose = True;ClosedLoop = True;Master = True;########################################################################################################################################## End of User defined variables.##########################################################################################################################################          ##############################################################################Main Program#############################################################################pp=raw_input("Participant identifier?")haptic_library_file = dir_path + haptic_library_titlefile_title = "Data_"+pp #name of the output filedownload_dir = dir_path + file_title + ".csv"  # define the filename to write toiteration = 0 #set iteration counter to 0. This is used to give each signal a unique ID for recording purposes. # Open and read the signal librarywith serial.Serial(arduinoport, 9600, timeout=0.5) as ser: # Open the Serial connection to the Arduino    with open(haptic_library_file, "rb") as HapticLibrary:        reader = csv.reader(HapticLibrary)        rows = [r for r in reader]        signal_length = (len(rows[0])/(channels+1))              Packet_Size = SUITCEYES.Handshake(ser, channels, sensors, Verbose, Feedback_Data_Wanted, Timing_Data_Wanted, ClosedLoop) #handshake with Arduino - send channels, sensors, etc and receive Packet_Size for future data transmissions. #main loop        with open(download_dir, "wb") as output:  # "w" indicates that you're writing strings to the file            while (len(rows)>iteration) or Signal_Select:                print("trial number =" + str(iteration))                if Signal_Select == True:                    select=raw_input("Select the Signal You Want to Display")                else:                    select=iteration                                if select == "override":                    signalentered = raw_input("Type in the signal you want to display")                    signal = signalentered.split(",")                                   elif select == "multichannel":                    signalentered = raw_input("Type in the signal you want to display")                    signal = signalentered.split(",")                elif select == "direct":                    channel_to_use = int(raw_input("Type in the channel you want to communicate with..."))                    signalentered = raw_input("Type in the signal you want to display")                    signal = signalentered.split(",")                elif select == "blankdirect":                    channel_to_use = int(raw_input("Type in the channel you want to communicate with..."))                    signalentered = raw_input("Type in the signal you want to display")                    signal = signalentered.split(",")                elif select == "blankmultichannel":                    signalentered = raw_input("Type in the signal you want to display")                    signal = signalentered.split(",")                else:                   signal = rows[int(select)]                raw_input("Press Enter key to start trial")                                    iteration += 1                            if select == "direct":                    print("I'm in direct mode!")                    Sensor, TimingData = SUITCEYES.DirectSignal(ser, channel_to_use, Packet_Size, signal, Verbose)                elif select == "multichannel":                    Sensor, TimingData = SUITCEYES.MultiDirectSignal(ser, Packet_Size, signal, Verbose)                elif select == "blankdirect":                    Sensor, TimingData = SUITCEYES.BlankDirectSignal(ser, channel_to_use, Packet_Size, signal, Verbose)                elif select == "blankmultichannel":                    Sensor, TimingData = SUITCEYES.BlankMultiDirectSignal(ser, Packet_Size, signal, Verbose)                else:                    Sensor, TimingData = SUITCEYES.TransmitSignal(ser, channels, Packet_Size, signal, Verbose)                if Feedback_Data_Wanted:                    print("Writing feedback file")                    feedback_dir = dir_path + "Feedback_Data_" + pp + "_"+ str(iteration)+ ".csv"                    SUITCEYES.WriteFeedback(feedback_dir, Sensor, Verbose)                print("Collecting Data from Arduino")                timing_dir = dir_path + "Timing_Data_" + pp + "_"+ str(iteration)+ ".csv"                if Timing_Data_Wanted:                    print("Writing timing data file")                    SUITCEYES.WriteTimingData(timing_dir, TimingData, Verbose)                                            print("Data collection complete")                condition=False                while condition ==False:                    answer = raw_input(prompt)  # enter response via keyboard                    condition = str.isdigit(answer)                row_out=signal+answer.split()                writer = csv.writer(output)                writer.writerow(row_out)